1. initialization of struct variable
typedef struct x{ type1 a; type2 b}x;
initialization ways:
1.1
x v;
x.a=a1;
x.b=b1;
In 1.2 and 1.3, it's better to do a type cast to the {} variable, although no
error in a stack variable(1.2), compiling error for a pointer(1.3).
1.2
x v;
v = (x){a1,a2};
v = (x){.a=a1,.b=b1};
1.3
x *v = (x*)malloc(sizeof(x));
*v = (x){a1,b1};


2. use == to compare pointers
If pointers are NULL or point the same address,
it returens true;
else
it returns false


3. main function must return a int result, cant return void

4. reference variable as a function arguments
void a(string &)
string b;
a(&b); // this is invalid
string &c = b;
a(c); // this is valid

4. the copy constructor of cpp is used for the object copy usage
Most cases needed a copy construtor are in deep copy conditions, meaning that
there's a pointer of the object's member variable needing to make a copy of  the object
it points to but the address only

5. use the parameter list of the constructors often.

6. vector find push_back

7. it's better to init an array, created with new method.
It seems that not all compilers will init the inside elements for you

8. if you  define a pointer pointing to an array with new method, you will
found that sizeof(the pointer)/sizeof(type) will not return the length of the array.
